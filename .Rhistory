gather(key = var_name, value = value, 2:ncol(wgs_1kg)) %>%
spread_(key = names(wgs_1kg)[1],value = 'value')
# substitute allels for NA, 0, 1 calls, change formate to interger
wgs_1kg[wgs_1kg == './.'] <- NA
wgs_1kg[wgs_1kg == '0/0'] <- 0
wgs_1kg[wgs_1kg == '1/1'] <- 1
wgs_1kg <- wgs_1kg %>%
select(var_name, snp.intersect$POS) %>%
mutate_at(vars(contains('mt')), as.integer)
wgs_1kg
## calculate MCC between imputed and typed SNPs
mccr.geno <- unlist(map2(wgs_1kg[,2:ncol(wgs_1kg)], imp_1kg[,2:ncol(imp_1kg)], function(a,b) mccr(a,b)))
##  Calculate concordance between imputed and typed SNPs
concodance.geno <- unlist(map2(imp_1kg[,2:ncol(imp_1kg)], wgs_1kg[,2:ncol(wgs_1kg)], function(a, b) sum(a == b, na.rm = T)/length(a)))
##  Calculate allele frequency of typed SNPs from WGS data
af <- unlist(map(wgs_1kg[,2:ncol(wgs_1kg)], function(a) sum(a, na.rm = T)/length(a)))
##  Dataframe for summary stats
summary.stats <- tibble(mtSNP = colnames(wgs_1kg[,2:ncol(wgs_1kg)]),
pos = as.integer(gsub('mt', '', colnames(wgs_1kg[,2:ncol(wgs_1kg)]))),
af = af,
mcc = mccr.geno,
concodance = concodance.geno)
##  merge on info.score file
summary.stats <- left_join(summary.stats, select(imp_1kg.info, c(-snp_id, -rs_id)), by = c('pos' = 'position'))
summary.stats <- mutate(summary.stats, info.cat = cut_width(summary.stats$info, 0.25, boundary = 0))
##  Plots by bp position - all SNPs
ggplot(summary.stats, aes(x = pos, y = mcc, colour = info.cat, size = af)) + geom_point() + theme_bw() +
labs(x = 'mtDNA position', y = 'MCC', title = 'Imputed mtSNP allele vs genotyped mtSNP allele') +
guides(colour=guide_legend(title="Impute2 Info \n Score > 0.4")) +
guides(size=guide_legend(title="Allele Frequency"))
ggplot(summary.stats, aes(x = pos, y = concodance, colour = info.cat, size = af)) + geom_point() + theme_bw() +
labs(x = 'mtDNA position', y = 'Concordance', title = 'Imputed mtSNP allele vs genotyped mtSNP allele') +
guides(colour=guide_legend(title="Impute2 Info \n Score > 0.4")) +
guides(size=guide_legend(title="Allele Frequency"))
##  Plots by bp position - all SNPs
ggplot(summary.stats, aes(x = pos, y = mcc, colour = info.cat, size = af)) + geom_point() + theme_bw() +
labs(x = 'mtDNA position', y = 'MCC', title = 'Imputed mtSNP allele vs sequenced mtSNP allele') +
guides(colour=guide_legend(title="Impute2 Info")) +
guides(size=guide_legend(title="Allele Frequency"))
ggplot(summary.stats, aes(x = pos, y = concodance, colour = info.cat, size = af)) + geom_point() + theme_bw() +
labs(x = 'mtDNA position', y = 'Concordance', title = 'Imputed mtSNP allele vs sequenced mtSNP allele') +
guides(colour=guide_legend(title="Impute2 Info")) +
guides(size=guide_legend(title="Allele Frequency"))
#   Imputed
## remove sites with poor info scores (< 0.3)
rm.info <- filter(summary.stats, info > 0.5)
rm.info
head(imp_1kg.ped)
select(imp_1kg.ped, rm.info)
select(imp_1kg.ped, -rm.info$POS)
select(imp_1kg.ped, -c(rm.info$POS))
rm.info
select(imp_1kg.ped, -c(rm.info$pos))
test <- select(imp_1kg.ped, -c(rm.info$pos))
dim(test)
dim(imp_1kg.ped)
filter(summary.stats, info > 0.5)
summary.stats
rm.info
test <- select(imp_1kg.ped, rm.info$pos)
test <- select(imp_1kg.ped, c(rm.info$pos))
rm.info$pos
rm.info$pos %in% colnames(imp_1kg.ped)
colnames(imp_1kg.ped) %in% rm.info$pos
#   Imputed
## remove sites with poor info scores (< 0.3)
test <- imp_1kg.ped[,colnames(imp_1kg.ped) %in% rm.info$pos]
dim(test)
View(test)
#   Imputed
## remove sites with poor info scores (< 0.3)
rm.info <- filter(summary.stats, info > 0.5)
imp_1kg.filtered <- imp_1kg.ped[,colnames(imp_1kg.ped) %in% rm.info$pos]
MTimp.classifications <- HiMC::getClassifications(imp_1kg.filtered)
MT_haps <- MTwgs.classifications %>%
left_join(MTtyp.classifications, by = 'Individual', suffix = c("_wgs", "_typ")) %>%
left_join(MTimp.classifications, by = 'Individual') %>%
rename(full_path_imp = full_path, haplogroup_imp = haplogroup) %>%
as.tibble()
imp_1kg.filtered
imp_1kg.filtered <- imp_1kg.ped[,colnames(imp_1kg.ped) %in% c('Individual', rm.info$pos)]
MTimp.classifications <- HiMC::getClassifications(imp_1kg.filtered)
MT_haps <- MTwgs.classifications %>%
left_join(MTtyp.classifications, by = 'Individual', suffix = c("_wgs", "_typ")) %>%
left_join(MTimp.classifications, by = 'Individual') %>%
rename(full_path_imp = full_path, haplogroup_imp = haplogroup) %>%
as.tibble()
## Count pairs of haplogroups of imputed and WGS assignments
hap.match <- MT_haps %>%
count(haplogroup_typ, haplogroup_wgs) %>%
mutate(match = haplogroup_typ == haplogroup_wgs)
## Use ggforce to tidy data for geom_parallel Sets
# Requires developmental version of ggforce
dat_ggforce <- hap.match  %>%
gather_set_data(1:2) %>%
arrange(x,haplogroup_wgs,desc(haplogroup_typ))
# Label Names for Aluvial diagram
dat_ggforce$z <- factor(dat_ggforce$y)
dat_ggforce$y <- as.numeric(factor(dat_ggforce$y))
dat_ggforce$y <- str_pad(dat_ggforce$y, 3, pad = "0")
# label Names for Imputed haplogroups
labs1 <- dat_ggforce %>%
filter(x == 'haplogroup_typ') %>%
arrange(y) %>%
dplyr::distinct(z)
labs1 <- as.character(labs1$z)
# label Names for WGS haplogroups
labs2 <- dat_ggforce %>%
filter(x == 'haplogroup_wgs') %>%
arrange(y) %>%
dplyr::distinct(z)
labs2 <- as.character(labs2$z)
ggplot(dat_ggforce, aes(x = x, id = id, split = y, value = n)) +
geom_parallel_sets(aes(fill = match), alpha = 0.5, axis.width = 0.2) +
geom_parallel_sets_labels(colour = 'black', angle = 0, label = c(labs1, labs2)) +
theme_classic() + theme(legend.position = 'bottom') +
theme(axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()) +
scale_x_discrete(labels=c("Typed", "WGS")) +
labs(x = "Mitochondrial Haplogroups") + scale_fill_brewer(palette = 'Set1')
## Count pairs of haplogroups of imputed and WGS assignments
hap.match <- MT_haps %>%
count(haplogroup_imp, haplogroup_wgs) %>%
mutate(match = haplogroup_imp == haplogroup_wgs)
## Use ggforce to tidy data for geom_parallel Sets
# Requires developmental version of ggforce
dat_ggforce <- hap.match  %>%
gather_set_data(1:2) %>%
arrange(x,haplogroup_wgs,desc(haplogroup_imp))
# Label Names for Aluvial diagram
dat_ggforce$z <- factor(dat_ggforce$y)
dat_ggforce$y <- as.numeric(factor(dat_ggforce$y))
dat_ggforce$y <- str_pad(dat_ggforce$y, 3, pad = "0")
# label Names for Imputed haplogroups
labs1 <- dat_ggforce %>%
filter(x == 'haplogroup_imp') %>%
arrange(y) %>%
dplyr::distinct(z)
labs1 <- as.character(labs1$z)
# label Names for WGS haplogroups
labs2 <- dat_ggforce %>%
filter(x == 'haplogroup_wgs') %>%
arrange(y) %>%
dplyr::distinct(z)
labs2 <- as.character(labs2$z)
ggplot(dat_ggforce, aes(x = x, id = id, split = y, value = n)) +
geom_parallel_sets(aes(fill = match), alpha = 0.5, axis.width = 0.2) +
geom_parallel_sets_labels(colour = 'black', angle = 0, label = c(labs1, labs2)) +
theme_classic() + theme(legend.position = 'bottom') +
theme(axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()) +
scale_x_discrete(labels=c("Imputed", "WGS")) +
labs(x = "Mitochondrial Haplogroups") + scale_fill_brewer(palette = 'Set1')
#   Imputed
## remove sites with poor info scores (< 0.3)
rm.info <- filter(summary.stats, info > 0.3)
imp_1kg.filtered <- imp_1kg.ped[,colnames(imp_1kg.ped) %in% c('Individual', rm.info$pos)]
MTimp.classifications <- HiMC::getClassifications(imp_1kg.filtered)
MT_haps <- MTwgs.classifications %>%
left_join(MTtyp.classifications, by = 'Individual', suffix = c("_wgs", "_typ")) %>%
left_join(MTimp.classifications, by = 'Individual') %>%
rename(full_path_imp = full_path, haplogroup_imp = haplogroup) %>%
as.tibble()
## Count pairs of haplogroups of imputed and WGS assignments
hap.match <- MT_haps %>%
count(haplogroup_imp, haplogroup_wgs) %>%
mutate(match = haplogroup_imp == haplogroup_wgs)
## Use ggforce to tidy data for geom_parallel Sets
# Requires developmental version of ggforce
dat_ggforce <- hap.match  %>%
gather_set_data(1:2) %>%
arrange(x,haplogroup_wgs,desc(haplogroup_imp))
# Label Names for Aluvial diagram
dat_ggforce$z <- factor(dat_ggforce$y)
dat_ggforce$y <- as.numeric(factor(dat_ggforce$y))
dat_ggforce$y <- str_pad(dat_ggforce$y, 3, pad = "0")
# label Names for Imputed haplogroups
labs1 <- dat_ggforce %>%
filter(x == 'haplogroup_imp') %>%
arrange(y) %>%
dplyr::distinct(z)
labs1 <- as.character(labs1$z)
# label Names for WGS haplogroups
labs2 <- dat_ggforce %>%
filter(x == 'haplogroup_wgs') %>%
arrange(y) %>%
dplyr::distinct(z)
labs2 <- as.character(labs2$z)
ggplot(dat_ggforce, aes(x = x, id = id, split = y, value = n)) +
geom_parallel_sets(aes(fill = match), alpha = 0.5, axis.width = 0.2) +
geom_parallel_sets_labels(colour = 'black', angle = 0, label = c(labs1, labs2)) +
theme_classic() + theme(legend.position = 'bottom') +
theme(axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()) +
scale_x_discrete(labels=c("Imputed", "WGS")) +
labs(x = "Mitochondrial Haplogroups") + scale_fill_brewer(palette = 'Set1')
#   Imputed
## remove sites with poor info scores (< 0.3)
rm.info <- filter(summary.stats, info > 0.8)
imp_1kg.filtered <- imp_1kg.ped[,colnames(imp_1kg.ped) %in% c('Individual', rm.info$pos)]
MTimp.classifications <- HiMC::getClassifications(imp_1kg.filtered)
MT_haps <- MTwgs.classifications %>%
left_join(MTtyp.classifications, by = 'Individual', suffix = c("_wgs", "_typ")) %>%
left_join(MTimp.classifications, by = 'Individual') %>%
rename(full_path_imp = full_path, haplogroup_imp = haplogroup) %>%
as.tibble()
## Count pairs of haplogroups of imputed and WGS assignments
hap.match <- MT_haps %>%
count(haplogroup_imp, haplogroup_wgs) %>%
mutate(match = haplogroup_imp == haplogroup_wgs)
## Use ggforce to tidy data for geom_parallel Sets
# Requires developmental version of ggforce
dat_ggforce <- hap.match  %>%
gather_set_data(1:2) %>%
arrange(x,haplogroup_wgs,desc(haplogroup_imp))
# Label Names for Aluvial diagram
dat_ggforce$z <- factor(dat_ggforce$y)
dat_ggforce$y <- as.numeric(factor(dat_ggforce$y))
dat_ggforce$y <- str_pad(dat_ggforce$y, 3, pad = "0")
# label Names for Imputed haplogroups
labs1 <- dat_ggforce %>%
filter(x == 'haplogroup_imp') %>%
arrange(y) %>%
dplyr::distinct(z)
labs1 <- as.character(labs1$z)
# label Names for WGS haplogroups
labs2 <- dat_ggforce %>%
filter(x == 'haplogroup_wgs') %>%
arrange(y) %>%
dplyr::distinct(z)
labs2 <- as.character(labs2$z)
ggplot(dat_ggforce, aes(x = x, id = id, split = y, value = n)) +
geom_parallel_sets(aes(fill = match), alpha = 0.5, axis.width = 0.2) +
geom_parallel_sets_labels(colour = 'black', angle = 0, label = c(labs1, labs2)) +
theme_classic() + theme(legend.position = 'bottom') +
theme(axis.title.y=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank()) +
scale_x_discrete(labels=c("Imputed", "WGS")) +
labs(x = "Mitochondrial Haplogroups") + scale_fill_brewer(palette = 'Set1')
readClipboard()
read.table(file = "clipboard", sep = "t", header=TRUE)
read.table(file = "clipboard", sep = "t", header=TRUE)
read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps')
dat <- read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps', col_names = F)
dat
gsub("[[:digit:]]","",dat)
gsub("[[:digit:]]","",dat$X1)
dat <- read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps', col_names = F) %>%
mutate(pos = as.numeric(str_extract(X1, "[0-9]+")))
dat
dat <- read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps', col_names = F) %>%
mutate(pos = as.numeric(str_extract(X1, "[0-9]+"))) %>%
mutate(allele = as.numeric(str_extract(X1, "[[:digit:]]"))) %>%
gsub("[[:digit:]]","",dat$X1)
dat <- read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps', col_names = F) %>%
mutate(pos = as.numeric(str_extract(X1, "[0-9]+"))) %>%
mutate(allele = as.numeric(str_extract(X1, "[A-Za-z]"))) %>%
gsub("[[:digit:]]","",dat$X1)
dat
dat <- read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps', col_names = F) %>%
mutate(pos = as.numeric(str_extract(X1, "[0-9]+"))) %>%
mutate(allele = as.numeric(str_extract(X1, "[A-Za-z]+")))
dat
dat <- read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps', col_names = F) %>%
mutate(pos = as.numeric(str_extract(X1, "[0-9]+"))) %>%
mutate(allele = as.numeric(str_extract(X1, "+[A-Za-z]")))
dat
wgs_1kg.vcf
dat <- read_tsv('/Users/sheaandrews/Documents/Test2/HiMC_snps', col_names = F) %>%
mutate(POS = as.numeric(str_extract(X1, "[0-9]+")))
semi_join(dat, wgs_1kg.vcf, by = 'POS')
anti_join(dat, wgs_1kg.vcf, by = 'POS')
semi_join(dat, wgs_1kg.vcf, by = 'POS')
semi_join(dat, imp.vcf, by = 'POS')
imp.vcf
imp_1kg.vcf
semi_join(dat, imp_1kg.vcf, by = 'POS')
library(tidyverse)
library(ggforce)
library(readxl)
library(HiMC); data(nodes)
##  Function
source('~/Dropbox/Research/PostDoc/MitoWax/3_Scripts/import_snps.R', chdir = TRUE)
##  Function for calculating mathews correlation coefficent (MCC)
# Moddifed from the mccr package
mccr <- function (act, pred)
{
TP <- sum(act %in% 1 & pred %in% 1)
TN <- sum(act %in% 0 & pred %in% 0)
FP <- sum(act %in% 0 & pred %in% 1)
FN <- sum(act %in% 1 & pred %in% 0)
denom <- as.double(TP + FP) * (TP + FN) * (TN + FP) * (TN + FN)
if (any((TP + FP) == 0, (TP + FN) == 0, (TN + FP) == 0, (TN + FN) == 0))
denom <- 1
mcc <- ((TP * TN) - (FP * FN))/sqrt(denom)
return(mcc)
}
##  Read in Thousand Genomes WGS
#     Plink .ped files
#     VCF Files
wgs_1kg.ped <- generate_snp_data(params$wgs.map, params$wgs.ped)
wgs_1kg.ped
wgs_1kg.ped <- generate_snp_data('/Users/sheaandrews/Desktop/chrMT_1kg_Human610-Quadv1_B-b37.map', '/Users/sheaandrews/Desktop/chrMT_1kg_Human610-Quadv1_B-b37.ped')
##  Function
source('~/Dropbox/Research/PostDoc/MitoWax/3_Scripts/import_snps.R', chdir = TRUE)
wgs_1kg.ped <- generate_snp_data('/Users/sheaandrews/Desktop/chrMT_1kg_Human610-Quadv1_B-b37.map', '/Users/sheaandrews/Desktop/chrMT_1kg_Human610-Quadv1_B-b37.ped')
?generate_snp_data
ref.vcf <- read_tsv(/Users/sheaandrews/Dropbox/src/MitoImpute/DerivedData/ReferencePanel/ReferencePanel_highQual_filtered.vcf.gz, comment = '##', na = c(".", "", "NA"))
source('~/.active-rstudio-document', echo=TRUE)
ref.vcf <- read_tsv('/Users/sheaandrews/Dropbox/src/MitoImpute/DerivedData/ReferencePanel/ReferencePanel_highQual_filtered.vcf.gz', comment = '##', na = c(".", "", "NA"))
ref.vcf
semi_join(dat, ref.vcf, by = 'POS')
anti_join(dat, ref.vcf, by = 'POS')
Preref.vcf <- read_tsv('/Users/sheaandrews/Dropbox/src/MitoImpute/DerivedData/ReferencePanel/ReferencePanel_highQual.vcf.gz', comment = '##', na = c(".", "", "NA"))
ref.vcf
anti_join(dat, Preref.vcf, by = 'POS')
anti_join(dat, ref.vcf, by = 'POS')
filter(Preref.vcf, POS %in% c(4977, 8703, 9950, 11177, 15535))
Preref.vcf %>% filter(POS %in% c(4977, 8703, 9950, 11177, 15535)) %>% select(POS, REF, ALT, INFO)
34138/41
41/34138
(41/34138)*100
(29/34138)*100
(311/34138)*100
(144/34138)*100
semPaths(fit.d, what = 'std', style = 'lisrel', layout = 'tree', intercepts = F, nCharNodes =  0, edge.label.position = c(rep(0.6, 15), rep(0.75, 16), rep(0.5, 22)), edge.color = c(rep('#3182bd', 15), rep('#de2d26', 16), rep('black', 22)), weighted = F,
nodeLabels = c('SDMT', 'TMT-A', 'CRT', 'SRT', 'Stroop', 'TMT-B', 'Zoo', 'DSB-T', 'DSB-S', 'BVRT', 'DR', 'IR', 'BNT', 'COWAT', 'Spot-Word', 'B-ADL', 'g\'', expression(delta)))
sem.d <- '
#Latent variables
g =~ zd_sdmt_tot + zd_traila2r + zd_MeanCRT + zd_MeanSRT + zd_stroopdiff + zd_tmt_diff  + zd_zoo + zd_digit_back + zd_DSB + zd_bvrt_b + zd_del_rec + zd_imm_rec1 + zd_BNT_15r  + zd_cowat + zd_spotword
d =~ zd_sdmt_tot + zd_traila2r + zd_MeanCRT + zd_MeanSRT + zd_stroopdiff + zd_tmt_diff  + zd_zoo + zd_digit_back + zd_DSB + zd_bvrt_b + zd_del_rec + zd_imm_rec1 + zd_BNT_15r  + zd_cowat + zd_spotword + zbayer
# correlated variances
zd_digit_back ~~ zd_DSB
zd_del_rec ~~ zd_imm_rec1
zd_MeanCRT ~~ zd_MeanSRT
# regressions
g ~ zadri + zEVGRS
d ~ zadri + zEVGRS
'
fit.d_r <- lavaan(sem.d, data = dat2, std.lv = TRUE, auto.var = T, estimator = "WLSM", se = "robust"); show(fit.d_r)
summary(fit.d_r, fit.measures = T, standardized=TRUE, rsquare = TRUE)
semPaths(fit.d_r, what = 'std', style = 'lisrel', layout = 'tree', intercepts = F, nCharNodes =  0)
semPaths(fit.d_r, what = 'path', style = 'lisrel', layout = 'tree', intercepts = F, edge.color = 'black', nCharNodes =  0, nodeLabels = c('SDMT', 'TMT-A', 'CRT', 'SRT', 'Stroop', 'TMT-B', 'Zoo', 'DSB-T', 'DSB-S', 'BVRT', 'CVLT-D', 'CVLT-I', 'BNT', 'COWAT', 'Spot-Word', 'Bayer', 'g\'', 'd'))
semPaths(fit.d_r, what = 'path', style = 'lisrel', layout = 'tree', intercepts = F, edge.color = 'black', nCharNodes =  0, nodeLabels = c('SDMT', 'TMT-A', 'CRT', 'SRT', 'Stroop', 'TMT-B', 'Zoo', 'DSB-T', 'DSB-S', 'BVRT', 'CVLT-D', 'CVLT-I', 'BNT', 'COWAT', 'Spot-Word', 'Bayer', 'ANU-ADRI', 'EV-GRS', 'g\'', 'd'))
semPaths(fit.d_r, what = 'path', style = 'lisrel', layout = 'tree', intercepts = F, edge.color = 'black', nCharNodes =  0, nodeLabels = c('SDMT', 'TMT-A', 'CRT', 'SRT', 'Stroop', 'TMT-B', 'Zoo', 'DSB-T', 'DSB-S', 'BVRT', 'CVLT-D', 'CVLT-I', 'BNT', 'COWAT', 'Spot-Word', 'Bayer', 'ANU-ADRI', 'EV-GRS', 'g\'', expression(delta)))
sem.domains <- '
#Latent variables
PS =~ 1*zd_sdmt_tot + zd_traila2r + zd_MeanCRT + zd_MeanSRT #
EF =~ 1*zd_stroopdiff + zd_tmt_diff + zd_zoo + zd_digit_back + zd_DSB
EM =~ 1*zd_bvrt_b + zd_del_rec + zd_imm_rec1
VA =~ 1*zd_BNT_15r + zd_cowat + zd_spotword
# correlated variances
zd_del_rec ~~ zd_imm_rec1
zd_digit_back ~~ zd_DSB
#zd_traila2r ~~ zd_tmt_diff
zd_MeanCRT ~~ zd_MeanSRT
zadri ~~ zEVGRS
#Factor Covariances
PS ~~ PS
EF ~~ EF
EM ~~ EM
VA ~~ VA
PS ~~ EF
PS ~~ EM
PS ~~ VA
EF ~~ EM
EF ~~ VA
EM ~~ VA
# regressions
PS ~ zadri + zEVGRS
EF ~ zadri + zEVGRS
EM ~ zadri + zEVGRS
VA ~ zadri + zEVGRS
'
fit.domains_r <- lavaan(sem.domains, data = dat2, auto.var = T, estimator = "WLSM", std.lv=TRUE)
summary(fit.domains_r, fit.measures = T, standardized=TRUE, rsquare = TRUE, ci = TRUE)
semPaths(fit.domains_r, what = 'std', intercepts = F, style = 'lisrel')
sem.g <- '
#Latent variables
g =~ zd_sdmt_tot + zd_traila2r + zd_MeanCRT + zd_MeanSRT + zd_stroopdiff + zd_tmt_diff + zd_zoo + zd_digit_back + zd_DSB + zd_bvrt_b + zd_del_rec + zd_imm_rec1 + zd_BNT_15r  + zd_cowat + zd_spotword
# correlated variances
zd_digit_back ~~ zd_DSB
zd_del_rec ~~ zd_imm_rec1
zd_MeanCRT ~~ zd_MeanSRT
# regressions
g ~ zadri + zEVGRS
'
fit.g_r <- lavaan(sem.g, data = dat2, std.lv = TRUE, auto.var = T, estimator = "WLSM"); show(fit.g_r)
summary(fit.g_r, fit.measures = T, standardized=TRUE, rsquare = TRUE)
semPaths(fit.g_r, what = 'std', style = 'lisrel', layout = 'tree', intercepts = F, nCharNodes =  0)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = params$rwd)
# ---- packages ----
library(tidyverse)
library(Hmisc)
library(ggplot2)
library(ggforce)
library(ggtern)
library(snpStats)
library(SNPRelate)
remove.packages('ggforce')
if (!require(devtools)) {
install.packages('devtools')
}
devtools::install_github('thomasp85/ggforce')
remove.packages('ggforce')
devtools::install_github("tidyverse/ggplot2")
if (!require(devtools)) {
install.packages('devtools')
}
devtools::install_github('thomasp85/ggforce')
devtools::install_git('https://bitbucket.org/nicholasehamilton/ggtern')
devtools::install_github("tidyverse/ggplot2")
library(ggplot2)
library(ggforce)
library(ggtern)
ggtern()
remove.packages('ggplot2')
remove.packages('ggplot2')
install.packages('ggplot2')
if (!require(devtools)) {
install.packages('devtools')
}
devtools::install_github('thomasp85/ggforce')
library(ggforce)
setwd(/Users/sheaandrews/Dropbox/src/GWASampleFiltering/)
setwd('/Users/sheaandrews/Dropbox/src/GWASampleFiltering/')
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = params$rwd)
## ---- Load Required R packages ---- ##
library(ggplot2)    ## For ploting
library(ggforce)    ## for zoom plots
library(GGally)     ## For Pairs plot
library(tidyverse)  ## for data wrangling
library(plotly)     ## For 3d interactive scatter plots
library(gridExtra)
##  Standarize varibles to have a mean of 0 and sd of 1
zscore = function(x){(x - mean(x)) / sd(x)}
##---- Read in Data ----##
# PCA file from plink
pca.raw <- as.tibble(read_delim(params$Path_eigenvec, delim = " ", col_names = F))
# population data file from 1000 genomes
base_pops.raw <- read_tsv(params$PATH_BasePops)
# population data from target set
target_pops.raw <- read_delim(params$Path_TargetPops, delim = " ", col_names = F)
# egien values
eigenval.raw <- read_table(params$Path_eigenval, col_names = F)
##---- Data wrangling ----##
##  rename column names in PCA file
colnames(pca.raw) <- c('FID', 'IID', paste0('PC', seq(1, ncol(pca.raw)-2, 1)))
##  standardize PC to a z-score
pca <- mutate_at(pca.raw, c('PC1', 'PC2', 'PC3', 'PC4', 'PC5', 'PC6', 'PC7', 'PC8', 'PC9', 'PC10'), zscore)
##  Proportion of variance explained by each PC in PCA
eigenval <- eigenval.raw %>%
mutate(PC = paste0('PC', 1:10)) %>%
rename(eigenval = X1) %>%
mutate(PC = factor(PC, levels = paste0('PC', 1:10))) %>%
mutate(PVE = round(eigenval / sum(eigenval), 3))
##  Munge population dataframes from 1000 genomes
base_pops <- base_pops.raw %>%
dplyr:::rename(IID = `Individual ID`) %>%
select(IID, Population) %>%
mutate(SuperPopulation = recode(base_pops.raw$Population, GBR = 'EUR', FIN = 'EUR', CHS = 'EAS', PUR = 'AMR', CDX = 'EAS', CLM = 'AMR', IBS = 'EUR', PEL = 'AMR', PJL = 'SAS', KHV = 'EAS', ACB = 'AFR', GWD = 'AFR', ESN = 'AFR', BEB = 'SAS', MSL = 'AFR', STU = 'SAS', ITU = 'SAS', CEU = 'EUR', YRI = 'AFR', CHB = 'EAS', JPT = 'EAS', LWK = 'AFR', ASW = 'AFR', MXL = 'AMR', TSI = 'EUR', GIH = 'SAS')) %>%
mutate(cohort = '1kgenomes')
##  Munge target population dataframes
target_pops <- target_pops.raw %>%
select(X2) %>%
rename(IID = X2) %>%
mutate(Population = params$Sample, SuperPopulation = params$Sample, cohort = params$Sample, Population_2 = params$Sample)
##  Munge PCA, base pop and target pop
pca <- target_pops %>%
bind_rows(base_pops) %>%
right_join(pca, by = 'IID')
##  Relevel Population Factor for ploting
pca$Population_2 <- factor(pca$Population, level = c(params$Sample, 'GBR', 'FIN', 'IBS', 'CEU', 'TSI', 'PUR', 'CLM', 'PEL', 'MXL', 'CHS', 'CDX', 'KHV', 'CHB', 'JPT', 'PJL', 'BEB', 'STU', 'ITU', 'GIH', 'GWD', 'ESN', 'MSL', 'YRI', 'LWK', 'ASW', 'ACB'))
#Include the number of PC for where the cumualtive PVE is 95%
PC.inc <-  findInterval(0.95, cumsum(eigenval$PVE)) + 1
## ---- Plot scree plot of proportion of varaince explained by Principal components ---- ##
p1 <- ggplot(data = eigenval, aes(x = PC, y = PVE, group = factor(1))) +
geom_point(colour = '#377EB8') + geom_path(colour = '#377EB8') +
labs(x = 'Principal Components') +
theme_bw() + ylim(0,1)
p2 <- ggplot(data = eigenval, aes(x=PC, y=cumsum(PVE), group = factor(1))) +
geom_point(colour = '#377EB8') + geom_path(colour = '#377EB8') +
labs(x = 'Principal Components', y = 'cumulative PVE') +
theme_bw() + ylim(0,1) + geom_hline(yintercept = 0.95, colour = '#E41A1C', linetype = 2)
grid.arrange(p1, p2, ncol = 2)
##---- Plot pairs plots ----##
GGally::ggpairs(pca, columns = paste0('PC', 1:PC.inc), aes(colour = SuperPopulation, shape = cohort)) +  theme_bw()
pca
paste0('PC', 1:PC.inc)
GGally::ggpairs(pca, columns = c(PC1, PC2, PC3, PC4), aes(colour = SuperPopulation, shape = cohort)) +  theme_bw()
GGally::ggpairs(pca, columns = c('PC1', PC2, PC3, PC4), aes(colour = SuperPopulation, shape = cohort)) +  theme_bw()
GGally::ggpairs(pca, columns = c('PC1', 'PC2', 'PC3', 'PC4'), aes(colour = SuperPopulation, shape = cohort)) +  theme_bw()
GGally::ggpairs(pca, columns = c('PC1', 'PC2', 'PC3', 'PC4'), aes(colour = 'SuperPopulation', shape = 'cohort')) +  theme_bw()
?ggpairs
pm <- select(pca,  paste0('PC', 1:PC.inc))
pm
pm <- select(pca,  paste0('PC', 1:PC.inc), SuperPopulation, cohort)
pm
GGally::ggpairs(pca, columns = 1:4, aes(colour = 'SuperPopulation', shape = 'cohort')) +  theme_bw()
GGally::ggpairs(pm, columns = 1:4, aes(colour = 'SuperPopulation', shape = 'cohort')) +  theme_bw()
data(flea)
ggpairs(flea, columns = 2:4)
pm <- ggpairs(flea, columns = 2:4, ggplot2::aes(colour=species))
p_(pm)
remove.packages('Ggally')
remove.packages('GGally')
